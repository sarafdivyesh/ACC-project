reinforcement learning tutorial - javatpoint ? scroll to top home java reinforcement learning ai blockchain html css javascript selenium control system jquery quiz projects interview q comment forum training reinforcement learning reinforcement learning tutorial related tutorials machine learning tutorial artificial intelligence tutorial nlp tutorial tensorflow tutorial pytorch tutorial data science tutorial reinforcement learning tutorial our reinforcement learning tutorial will give you a complete overview of reinforcement learning, including mdp and q-learning. in rl tutorial, you will learn the below topics: what is reinforcement learning? terms used in reinforcement learning. key features of reinforcement learning. elements of reinforcement learning. approaches to implementing reinforcement learning. how does reinforcement learning work? the bellman equation. types of reinforcement learning. reinforcement learning algorithm. markov decision process. what is q-learning? difference between supervised learning and reinforcement learning. applications of reinforcement learning. conclusion. what is reinforcement learning? reinforcement learning is a feedback-based machine learning technique in which an agent learns to behave in an environment by performing the actions and seeing the results of actions. for each good action, the agent gets positive feedback, and for each bad action, the agent gets negative feedback or penalty. in reinforcement learning, the agent learns automatically using feedbacks without any labeled data, unlike supervised learning. since there is no labeled data, so the agent is bound to learn by its experience only. rl solves a specific type of problem where decision making is sequential, and the goal is long-term, such as game-playing, robotics, etc. the agent interacts with the environment and explores it by itself. the primary goal of an agent in reinforcement learning is to improve the performance by getting the maximum positive rewards. the agent learns with the process of hit and trial, and based on the experience, it learns to perform the task in a better way. hence, we can say that "reinforcement learning is a type of machine learning method where an intelligent agent (computer program) interacts with the environment and learns to act within that." how a robotic dog learns the movement of his arms is an example of reinforcement learning. it is a core part of artificial intelligence, and all ai agent works on the concept of reinforcement learning. here we do not need to pre-program the agent, as it learns from its own experience without any human intervention. example: suppose there is an ai agent present within a maze environment, and his goal is to find the diamond. the agent interacts with the environment by performing some actions, and based on those actions, the state of the agent gets changed, and it also receives a reward or penalty as feedback. the agent continues doing these three things (take action, change state/remain in the same state, and get feedback), and by doing these actions, he learns and explores the environment. the agent learns that what actions lead to positive feedback or rewards and what actions lead to negative feedback penalty. as a positive reward, the agent gets a positive point, and as a penalty, it gets a negative point. terms used in reinforcement learning agent(): an entity that can perceive/explore the environment and act upon it. environment(): a situation in which an agent is present or surrounded by. in rl, we assume the stochastic environment, which means it is random in nature. action(): actions are the moves taken by an agent within the environment. state(): state is a situation returned by the environment after each action taken by the agent. reward(): a feedback returned to the agent from the environment to evaluate the action of the agent. policy(): policy is a strategy applied by the agent for the next action based on the current state. value(): it is expected long-term retuned with the discount factor and opposite to the short-term reward. q-value(): it is mostly similar to the value, but it takes one additional parameter as a current action (a). key features of reinforcement learning in rl, the agent is not instructed about the environment and what actions need to be taken. it is based on the hit and trial process. the agent takes the next action and changes states according to the feedback of the previous action. the agent may get a delayed reward. the environment is stochastic, and the agent needs to explore it to reach to get the maximum positive rewards. approaches to implement reinforcement learning there are mainly three ways to implement reinforcement-learning in ml, which are: value-based: the value-based approach is about to find the optimal value function, which is the maximum value at a state under any policy. therefore, the agent expects the long-term return at any state(s) under policy ?. policy-based: policy-based approach is to find the optimal policy for the maximum future rewards without using the value function. in this approach, the agent tries to apply such a policy that the action performed in each step helps to maximize the future reward. the policy-based approach has mainly two types of policy: deterministic: the same action is produced by the policy (?) at any state. stochastic: in this policy, probability determines the produced action. model-based: in the model-based approach, a virtual model is created for the environment, and the agent explores that environment to learn it. there is no particular solution or algorithm for this approach because the model representation is different for each environment. elements of reinforcement learning there are four main elements of reinforcement learning, which are given below: policy reward signal value function model of the environment 1) policy: a policy can be defined as a way how an agent behaves at a given time. it maps the perceived states of the environment to the actions taken on those states. a policy is the core element of the rl as it alone can define the behavior of the agent. in some cases, it may be a simple function or a lookup table, whereas, for other cases, it may involve general computation as a search process. it could be deterministic or a stochastic policy: for deterministic policy: a = ?(s) for stochastic policy: ?(a | s) = p[at =a | st = s] 2) reward signal: the goal of reinforcement learning is defined by the reward signal. at each state, the environment sends an immediate signal to the learning agent, and this signal is known as a reward signal. these rewards are given according to the good and bad actions taken by the agent. the agent's main objective is to maximize the total number of rewards for good actions. the reward signal can change the policy, such as if an action selected by the agent leads to low reward, then the policy may change to select other actions in the future. 3) value function: the value function gives information about how good the situation and action are and how much reward an agent can expect. a reward indicates the immediate signal for each good and bad action, whereas a value function specifies the good state and action for the future. the value function depends on the reward as, without reward, there could be no value. the goal of estimating values is to achieve more rewards. 4) model: the last element of reinforcement learning is the model, which mimics the behavior of the environment. with the help of the model, one can make inferences about how the environment will behave. such as, if a state and an action are given, then a model can predict the next state and reward. the model is used for planning, which means it provides a way to take a course of action by considering all future situations before actually experiencing those situations. the approaches for solving the rl problems with the help of the model are termed as the model-based approach. comparatively, an approach without using a model is called a model-free approach. how does reinforcement learning work? to understand the working process of the rl, we need to consider two main things: environment: it can be anything such as a room, maze, football ground, etc. agent: an intelligent agent such as ai robot. let's take an example of a maze environment that the agent needs to explore. consider the below image: in the above image, the agent is at the very first block of the maze. the maze is consisting of an s6 block, which is a wall, s8 a fire pit, and s4 a diamond block. the agent cannot cross the s6 block, as it is a solid wall. if the agent reaches the s4 block, then get the +1 reward; if it reaches the fire pit, then gets -1 reward point. it can take four actions: move up, move down, move left, and move right. the agent can take any path to reach to the final point, but he needs to make it in possible fewer steps. suppose the agent considers the path s9-s5-s1-s2-s3, so he will get the +1-reward point. the agent will try to remember the preceding steps that it has taken to reach the final step. to memorize the steps, it assigns 1 value to each previous step. consider the below step: now, the agent has successfully stored the previous steps assigning the 1 value to each previous block. but what will the agent do if he starts moving from the block, which has 1 value block on both sides? consider the below diagram: it will be a difficult condition for the agent whether he should go up or down as each block has the same value. so, the above approach is not suitable for the agent to reach the destination. hence to solve the problem, we will use the bellman equation, which is the main concept behind reinforcement learning. the bellman equation the bellman equation was introduced by the mathematician richard ernest bellman in the year 1953, and hence it is called as a bellman equation. it is associated with dynamic programming and used to calculate the values of a decision problem at a certain point by including the values of previous states. it is a way of calculating the value functions in dynamic programming or environment that leads to modern reinforcement learning. the key-elements used in bellman equations are: action performed by the agent is referred to as "a" state occurred by performing the action is "s." the reward/feedback obtained for each good and bad action is "r." a discount factor is gamma "?." the bellman equation can be written as: 
v(s) = max [r(s,a) + ?v(s`)]
 where, v(s)= value calculated at a particular point. r(s,a) = reward at a particular state s by performing an action. ? = discount factor v(s`) = the value at the previous state. in the above equation, we are taking the max of the complete values because the agent tries to find the optimal solution always. so now, using the bellman equation, we will find value at each state of the given environment. we will start from the block, which is next to the target block. for 1st block: v(s3) = max [r(s,a) + ?v(s`)], here v(s')= 0 because there is no further state to move. v(s3)= max[r(s,a)]=> v(s3)= max[1]=> v(s3)= 1. for 2nd block: v(s2) = max [r(s,a) + ?v(s`)], here ?= 0.9(lets), v(s')= 1, and r(s, a)= 0, because there is no reward at this state. v(s2)= max[0.9(1)]=> v(s)= max[0.9]=> v(s2) =0.9 for 3rd block: v(s1) = max [r(s,a) + ?v(s`)], here ?= 0.9(lets), v(s')= 0.9, and r(s, a)= 0, because there is no reward at this state also. v(s1)= max[0.9(0.9)]=> v(s3)= max[0.81]=> v(s1) =0.81 for 4th block: v(s5) = max [r(s,a) + ?v(s`)], here ?= 0.9(lets), v(s')= 0.81, and r(s, a)= 0, because there is no reward at this state also. v(s5)= max[0.9(0.81)]=> v(s5)= max[0.81]=> v(s5) =0.73 for 5th block: v(s9) = max [r(s,a) + ?v(s`)], here ?= 0.9(lets), v(s')= 0.73, and r(s, a)= 0, because there is no reward at this state also. v(s9)= max[0.9(0.73)]=> v(s4)= max[0.81]=> v(s4) =0.66 consider the below image: now, we will move further to the 6th block, and here agent may change the route because it always tries to find the optimal path. so now, let's consider from the block next to the fire pit. now, the agent has three options to move; if he moves to the blue box, then he will feel a bump if he moves to the fire pit, then he will get the -1 reward. but here we are taking only positive rewards, so for this, he will move to upwards only. the complete block values will be calculated using this formula. consider the below image: types of reinforcement learning there are mainly two types of reinforcement learning, which are: positive reinforcement negative reinforcement positive reinforcement: the positive reinforcement learning means adding something to increase the tendency that expected behavior would occur again. it impacts positively on the behavior of the agent and increases the strength of the behavior. this type of reinforcement can sustain the changes for a long time, but too much positive reinforcement may lead to an overload of states that can reduce the consequences. negative reinforcement: the negative reinforcement learning is opposite to the positive reinforcement as it increases the tendency that the specific behavior will occur again by avoiding the negative condition. it can be more effective than the positive reinforcement depending on situation and behavior, but it provides reinforcement only to meet minimum behavior. how to represent the agent state? we can represent the agent state using the markov state that contains all the required information from the history. the state st is markov state if it follows the given condition: p[st+1 | st ] = p[st +1 | s1,......, st]
 the markov state follows the markov property, which says that the future is independent of the past and can only be defined with the present. the rl works on fully observable environments, where the agent can observe the environment and act for the new state. the complete process is known as markov decision process, which is explained below: markov decision process markov decision process or mdp, is used to formalize the reinforcement learning problems. if the environment is completely observable, then its dynamic can be modeled as a markov process. in mdp, the agent constantly interacts with the environment and performs actions; at each action, the environment responds and generates a new state. mdp is used to describe the environment for the rl, and almost all the rl problem can be formalized using mdp. mdp contains a tuple of four elements (s, a, pa, ra): a set of finite states s a set of finite actions a rewards received after transitioning from state s to state s', due to action a. probability pa. mdp uses markov property, and to better understand the mdp, we need to learn about it. markov property: it says that "if the agent is present in the current state s1, performs an action a1 and move to the state s2, then the state transition from s1 to s2 only depends on the current state and future action and states do not depend on past actions, rewards, or states." or, in other words, as per markov property, the current state transition does not depend on any past action or state. hence, mdp is an rl problem that satisfies the markov property. such as in a chess game, the players only focus on the current state and do not need to remember past actions or states. finite mdp: a finite mdp is when there are finite states, finite rewards, and finite actions. in rl, we consider only the finite mdp. markov process: markov process is a memoryless process with a sequence of random states s1, s2, ....., st that uses the markov property. markov process is also known as markov chain, which is a tuple (s, p) on state s and transition function p. these two components (s and p) can define the dynamics of the system. reinforcement learning algorithms reinforcement learning algorithms are mainly used in ai applications and gaming applications. the main used algorithms are: q-learning: q-learning is an off policy rl algorithm, which is used for the temporal difference learning. the temporal difference learning methods are the way of comparing temporally successive predictions. it learns the value function q (s, a), which means how good to take action "a" at a particular state "s." the below flowchart explains the working of q- learning: state action reward state action (sarsa): sarsa stands for state action reward state action, which is an on-policy temporal difference learning method. the on-policy control method selects the action for each state while learning using a specific policy. the goal of sarsa is to calculate the q ? (s, a) for the selected current policy ? and all pairs of (s-a). the main difference between q-learning and sarsa algorithms is that unlike q-learning, the maximum reward for the next state is not required for updating the q-value in the table. in sarsa, new action and reward are selected using the same policy, which has determined the original action. the sarsa is named because it uses the quintuple q(s, a, r, s', a'). where, s: original state a: original action r: reward observed while following the states s' and a': new state, action pair. deep q neural network (dqn): as the name suggests, dqn is a q-learning using neural networks. for a big state space environment, it will be a challenging and complex task to define and update a q-table. to solve such an issue, we can use a dqn algorithm. where, instead of defining a q-table, neural network approximates the q-values for each action and state. now, we will expand the q-learning. q-learning explanation: q-learning is a popular model-free reinforcement learning algorithm based on the bellman equation. the main objective of q-learning is to learn the policy which can inform the agent that what actions should be taken for maximizing the reward under what circumstances. it is an off-policy rl that attempts to find the best action to take at a current state. the goal of the agent in q-learning is to maximize the value of q. the value of q-learning can be derived from the bellman equation. consider the bellman equation given below: in the equation, we have various components, including reward, discount factor (?), probability, and end states s'. but there is no any q-value is given so first consider the below image: in the above image, we can see there is an agent who has three values options, v(s1), v(s2), v(s3). as this is mdp, so agent only cares for the current state and the future state. the agent can go to any direction (up, left, or right), so he needs to decide where to go for the optimal path. here agent will take a move as per probability bases and changes the state. but if we want some exact moves, so for this, we need to make some changes in terms of q-value. consider the below image: q- represents the quality of the actions at each state. so instead of using a value at each state, we will use a pair of state and action, i.e., q(s, a). q-value specifies that which action is more lubricative than others, and according to the best q-value, the agent takes his next move. the bellman equation can be used for deriving the q-value. to perform any action, the agent will get a reward r(s, a), and also he will end up on a certain state, so the q -value equation will be: hence, we can say that, v(s) = max [q(s, a)] the above formula is used to estimate the q-values in q-learning. what is 'q' in q-learning? the q stands for quality in q-learning, which means it specifies the quality of an action taken by the agent. q-table: a q-table or matrix is created while performing the q-learning. the table follows the state and action pair, i.e., [s, a], and initializes the values to zero. after each action, the table is updated, and the q-values are stored within the table. the rl agent uses this q-table as a reference table to select the best action based on the q-values. difference between reinforcement learning and supervised learning the reinforcement learning and supervised learning both are the part of machine learning, but both types of learnings are far opposite to each other. the rl agents interact with the environment, explore it, take action, and get rewarded. whereas supervised learning algorithms learn from the labeled dataset and, on the basis of the training, predict the output. the difference table between rl and supervised learning is given below: reinforcement learning supervised learning rl works by interacting with the environment. supervised learning works on the existing dataset. the rl algorithm works like the human brain works when making some decisions. supervised learning works as when a human learns things in the supervision of a guide. there is no labeled dataset is present the labeled dataset is present. no previous training is provided to the learning agent. training is provided to the algorithm so that it can predict the output. rl helps to take decisions sequentially. in supervised learning, decisions are made when input is given. reinforcement learning applications robotics: rl is used in robot navigation, robo-soccer, walking, juggling, etc. control: rl can be used for adaptive control such as factory processes, admission control in telecommunication, and helicopter pilot is an example of reinforcement learning. game playing: rl can be used in game playing such as tic-tac-toe, chess, etc. chemistry: rl can be used for optimizing the chemical reactions. business: rl is now used for business strategy planning. manufacturing: in various automobile manufacturing companies, the robots use deep reinforcement learning to pick goods and put them in some containers. finance sector: the rl is currently used in the finance sector for evaluating trading strategies. conclusion: from the above discussion, we can say that reinforcement learning is one of the most interesting and useful parts of machine learning. in rl, the agent explores the environment by exploring it without any human intervention. it is the main learning algorithm that is used in artificial intelligence. but there are some cases where it should not be used, such as if you have enough data to solve the problem, then other ml algorithms can be used more efficiently. the main issue with the rl algorithm is that some of the parameters may affect the speed of the learning, such as delayed feedback. for videos join our youtube channel: join now feedback send your feedback to [email protected] help others, please share learn latest tutorials splunk spss swagger transact-sql tumblr reactjs regex reinforcement learning r programming rxjs react native python design patterns python pillow python turtle keras preparation aptitude reasoning verbal ability interview questions company questions trending technologies artificial intelligence aws selenium cloud computing hadoop reactjs data science angular 7 blockchain git machine learning devops b.tech / mca dbms data structures daa operating system computer network compiler design computer organization discrete mathematics ethical hacking computer graphics software engineering web technology cyber security automata c programming c++ java .net python programs control system data mining data warehouse javatpoint services javatpoint offers too many high quality services. mail us on [email protected], to get more information about given services. website designing website development java development php development wordpress graphic designing logo digital marketing on page and off page seo ppc content development corporate training classroom and online training data entry training for college campus javatpoint offers college campus training on core java, advance java, .net, android, hadoop, php, web technology and python. please mail your requirement at [email protected] duration: 1 week to 2 week like/subscribe us for latest updates or newsletter learn tutorialslearn javalearn data structureslearn c programminglearn c++ tutoriallearn c# tutoriallearn php tutoriallearn html tutoriallearn javascript tutoriallearn jquery tutoriallearn spring tutorial our websitesjavatpoint.comhindi100.comlyricsia.comquoteperson.comjobandplacement.com our services website development android development website designing digital marketing summer training industrial training college campus training contact address: g-13, 2nd floor, sec-3 noida, up, 201301, india contact no: 0120-4256464, 9990449935contact us subscribe us privacy policysitemap about me ? copyright 2011-2021 www.javatpoint.com. all rights reserved. developed by javatpoint.