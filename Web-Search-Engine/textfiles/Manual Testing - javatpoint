manual testing - javatpoint ? scroll to top home software testing selenium appium jmeter junit postman jira testng soapui uipath rpa qa selenium python interview q software testing tutorial software testing principles software development life cycle software testing life cycle types of software testing levels of testing test maturity model sdlc models waterfall model spiral model hybrid model prototype model v-model types of testing manual testing automation testing types of manual white box testing black box testing grey box testing white box techniques data flow testing control flow testing branch coverage testing statement coverage testing decision coverage testing black box techniques decision table all-pair testing cause-effect testing state transition use case types of black box functional testing non-functional testing types of functional unit testing integration testing system testing types of non-functional performance testing usability testing compatibility testing test case development testing documentation test scenario test case testing techniques error guessing equivalence portioning boundary value analysis test management test plan test case review process requirement traceability matrix defect tracking bug in software testing bug life cycle severity & priority test environment defect management process other types of testing regression testing smoke testing sanity testing static testing dynamic testing load testing stress testing recovery testing exploratory testing visual testing acceptance testing alpha testing beta testing database testing mainframe testing adhoc testing globalization testing mutation testing security testing accessibility testing structural testing volume testing scalability testing stability testing spike testing negative testing positive testing endurance testing reliability testing monkey testing agile testing component testing gui testing test strategy software testing tools software testing tools test management tools defect/bug tracking tools automation testing tools performance testing tools cross-browser testing tools integration testing tools unit testing tools mobile testing tools gui testing tools security testing tools penetration testing tools differences automation testing vs manual testing load testing vs stress testing smoke testing vs sanity testing system testing vs acceptance testing quality assurance vs quality control static testing vs dynamic testing verification vs validation testing alpha testing vs beta testing black box vs. white box vs. grey box testing globalization testing vs localization testing test case vs test scenarios test plan vs test strategy boundary value analysis vs equivalence partitioning sdlc vs stlc bug vs defect vs error vs fault vs failure testing vs debugging frontend testing vs backend testing hld vs lld brs vs srs positive testing vs negative testing top-down vs bottom-up integration testing use case vs test case monkey testing vs gorilla testing stubs vs drivers component testing vs unit testing software testing vs embedded testing gui testing vs usability testing sdet vs tester desktop application testing vs client-server application testing vs web application testing software testing mcq software testing mcq software testing mcq part 2 interview questions software testing interview next ? ? prev manual testing manual testing is a software testing process in which test cases are executed manually without using any automated tool. all test cases executed by the tester manually according to the end user's perspective. it ensures whether the application is working, as mentioned in the requirement document or not. test cases are planned and implemented to complete almost 100 percent of the software application. test case reports are also generated manually. manual testing is one of the most fundamental testing processes as it can find both visible and hidden defects of the software. the difference between expected output and output, given by the software, is defined as a defect. the developer fixed the defects and handed it to the tester for retesting. manual testing is mandatory for every newly developed software before automated testing. this testing requires great efforts and time, but it gives the surety of bug-free software. manual testing requires knowledge of manual testing techniques but not of any automated testing tool. manual testing is essential because one of the software testing fundamentals is "100% automation is not possible." why we need manual testing whenever an application comes into the market, and it is unstable or having a bug or issues or creating a problem while end-users are using it. if we don't want to face these kinds of problems, we need to perform one round of testing to make the application bug free and stable and deliver a quality product to the client, because if the application is bug free, the end-user will use the application more conveniently. if the test engineer does manual testing, he/she can test the application as an end-user perspective and get more familiar with the product, which helps them to write the correct test cases of the application and give the quick feedback of the application. types of manual testing there are various methods used for manual testing. each technique is used according to its testing criteria. types of manual testing are given below: white box testing black box testing gray box testing white-box testing the white box testing is done by developer, where they check every line of a code before giving it to the test engineer. since the code is visible for the developer during the testing, that's why it is also known as white box testing. for more information about white box testing, refers to the below link: https://www.javatpoint.com/white-box-testing black box testing the black box testing is done by the test engineer, where they can check the functionality of an application or the software according to the customer /client's needs. in this, the code is not visible while performing the testing; that's why it is known as black-box testing. for more information about black-box testing, refers to the below link: https://www.javatpoint.com/black-box-testing gray box testing gray box testing is a combination of white box and black box testing. it can be performed by a person who knew both coding and testing. and if the single person performs white box, as well as black-box testing for the application, is known as gray box testing. to get more details about gray box testing, refers to the below link: https://www.javatpoint.com/grey-box-testing how to perform manual testing first, tester observes all documents related to software, to select testing areas. tester analyses requirement documents to cover all requirements stated by the customer. tester develops the test cases according to the requirement document. all test cases are executed manually by using black box testing and white box testing. if bugs occurred then the testing team informs the development team. the development team fixes bugs and handed software to the testing team for a retest. software build process once the requirement is collected, it will provide to the two different team development and testing team. after getting the requirement, the concerned developer will start writing the code. and in the meantime, the test engineer understands the requirement and prepares the required documents, up to now the developer may complete the code and store in the control version tool. after that, the code changes in the ui, and these changes handle by one separate team, which is known as the build team. this build team will take the code and start compile and compress the code with the help of a build tool. once we got some output, the output goes in the zip file, which is known as build (application or software).each build will have some unique number like (b001, b002). then this particular build will be installed in the test server. after that, the test engineer will access this test server with the help of the test url and start testing the application. if the test engineer found any bug, he/she will be reported to the concerned developer. then the developer will reproduce the bug in the test server and fix the bug and again store the code in the control version tool, and it will install the new updated file and remove the old file; this process is continued until we get the stable build. once we got the stable build, it will be handed over to the customer. note1 once we collect the file from the control version tool, we will use the build tool to compile the code from high-level language to machine level language. after compilation, if the file size will increase, so we will compress that particular file and dumped into the test server. this process is done by build team, developer (if build team is not there, a developer can do it) or the test lead (if the build team directly handle the zip and install the application to the test server and inform the test engineer). generally, we can't get a new build for every bug; else, most of the time will be wasted only in creating the builds. note2 build team the main job of the build team is to create the application or the build and converting the high-level language into low-level language. build it is software, which is used to convert the code into application format. and it consists of some set of features and bug fixes that are handed over to the test engineer for testing purposes until it becomes stable. control version tool it is a software or application, which is used for the following purpose: in this tool, we can save different types of files. it is always secured because we access the file from the tools using the same login credentials. the primary objective of the tools is to track the changes done for the existing files. example of build process let see one example to understand how to build process work on the real scenarios: as soon as the test engineer gets the bug, they will send it to the developers, and they need some time to analyze; after that, he/she only fixes the bug (test engineer can't give the collection of bug). the developer is decided how many bugs he can fix according to their time. and the test engineer is decided, which bug should be fixed first according to their needs because the test engineers cannot afford to stop testing. and the test engineer getting the mail, they can only know that which bug is fixed by the list of the bug fixes. the time will increase because at the first build, and developers should write the code in the different features. and at the end, he/she can only do the bug fixes and the numbers of days will be decreased. note3 test cycle the test cycle is the time duration given to the test engineer to test every build. differences between the two build the bugs found in one build and can be fixed any of the future build, which depends on the test engineer's requirement. each new build is the modified version of the old one, and these modifications could be the bug fixes or adding some new features. how frequently we were getting the new build in the beginning, we used to get weekly builds, but in the latest stage of testing, when the application was getting stable, we used to get the new build once in 3 days, two days, or a daily basis as well. how many builds we get if we consider one year of any project duration, we got 22-26 builds. when we get the bug fixes generally, we understand the bug fixes only after the test cycle is completed, or the collection of bugs is fixed in one build, and handover in the next builds. advantages of manual testing it does not require programming knowledge while using the black box method. it is used to test dynamically changing gui designs. tester interacts with software as a real user so that they are able to discover usability and user interface issues. it ensures that the software is a hundred percent bug-free. it is cost-effective. easy to learn for new testers. disadvantages of manual testing it requires a large number of human resources. it is very time-consuming. tester develops test cases based on their skills and experience. there is no evidence that they have covered all functions or not. test cases cannot be used again. need to develop separate test cases for each new software. it does not provide testing on all aspects of testing. since two teams work together, sometimes it is difficult to understand each other's motives, it can mislead the process. manual testing tools in manual testing, different types of testing like unit, integration, security, performance, and bug tracking, we have various tools such as jira, bugzilla, mantis, zap, nunit, tessy, loadrunner, citrus, sonarqube, etc. available in the market. some of the tools are open-source, and some are commercial. for more information about testing tools, refers to the below link: https://www.javatpoint.com/software-testing-tools let's us understand them one by one: loadrunner it is most commonly used performance testing tools. loadrunner is mainly used to support performance testing for the wide range of procedures, number of approaches, and application environments. the main purpose of executing the loadrunner tool is to classify the most common sources of performance issues quickly. features of loadrunner loadrunner tool contains n-numbers of applications, which reduces the time to understand and describe the reports. we can get thorough performance test reports by using the loadrunner tool. it will reduce the cost of distributed load testing and also offer the operational tool for deployment tracking. citrus citrus is an integration testing tool, which is the most commonly used test framework. it is written in java programming language. it is mostly used to request and respond to server-side and client-side and validate the xml json files. to accomplish the end-to-end use case testing, citrus supports several http, jms, and soap protocols. characteristics of citrus following are some of the important features of citrus tool: it is used to send and receive messages. citrus is available as both an open-source and a licensed in the market. it delivers a low-cost solution. we can authenticate the database by using the citrus tool. it will describe the sequence of messages, offer the test plan, and document the test coverage. it creates the message and verifies the responses. zap zap is an open-source web application security scanner. it is stands for zed attack proxy. just like some other tools, it is also written in the java programming language. it is the most effective open web application security projects [owasp]. features of zap it supports many operating systems such as windows, linux, os x. it has a plugin-based architecture. it contains an online marketplace that permits us to add new or updated features. zap's gui control panel is easy to use. nunit nunit is one of the most frequently used unit testing tools. it is an open-source tool and primarily derived from the junit. it was completely written in the c# programming language and suitable for all .net languages. in other words, we can say that the nunit tool is entirely redesigned to become the advantage of many .net language qualities. for example: reflection-related capabilities. other custom attributes. characteristics of nunit it allows the assertions as a static method of the advantage class. it sustains the data-driven tests. it supports several platforms, like .net core xamarin mobile, silverlight, and efficient framework. the ability of nunit help us to execute the tests simultaneously. it uses a console runner to load and execute the tests. jira the most regularly used bug tracking tool is jira, which is an open-source tool. it is used for bug tracking, project management, and issue tracking. in this tool, we can easily track all kinds of bugs or defects related to the software and produced by the test engineers. features of jira it is a time-saving tool. jira is used to track the defects and issues. it is used to establish the documentation tasks. jira is a very useful tool in tracking the improvement of our documentation. to get the complete information about the jira tool, refer to the below link: https://www.javatpoint.com/jira-tutorial. sonarqube another testing tool of manual testing is sonarqube, which improves our workflow with continuous code quality and code security. it is flexible with the use of plug-ins. it is completely written in the java programming language. it offers fully automated evaluation and integration with ant, maven, gradle, msbuild, and constant integration tools. sonarqube has the ability to record a metrics history and gives the evolution graph. features of sonarqube below are some of the significant features of the sonarqube tool: it supports several programming languages like c, c++, python, java, html, css, vb.net, php, cobol, pl/sql, etc. under the gnu lesser general public license, sonarqube is freely available. sonarqube is affiliate with some important external tools like github, active directory, ldap, and others. sonarqube merged with visual studio, eclipse, and intellij idea development environments due to the sonarlint plug-ins. jmeter jmeter is an open-source tool that is used to test the performance of both static and dynamic resources and dynamic web applications. it is completely designed on the java application to load the functional test behavior and measure the application's performance. it facilitates users or developers to use the source code for the development of other applications. features of jmeter below are some of the essential characteristics of jmeter: it is platform-independent, which accepts a jvm like windows, mac, and linux, etc. it supports a user-friendly gui, which is interactive and straightforward. it is incredibly extensible to load the performance test in multiple types of servers. for more information about jmeter, refers to the below link: https://www.javatpoint.com/jmeter-tutorial. bugzilla another bug tracking tool used in manual testing is bugzilla. it is most widely used by many organizations to track the various bugs of the application. bugzilla is an open-source tool that helps the customer and the client to keep track of the defects. bugzilla is also considered a test management tool because in this, we can easily link other test case management tools such as alm, quality centre, etc. features of bugzilla bugzilla has some additional features which help us to report the bug easily: it supports various operating systems such as windows, linux, and mac. with the help of bugzilla, we can list a bug in several formats. user preferences can measure email notification. bugzilla has advanced searching capabilities. mantis mantis is a web-based bug tracking system. manitsbt stands for mantis bug tracker. it is used to follow the software defects and performed in the php programming language. it is also an open-source tool. features of mantis some of the standard features of the particular tool are as follows: with the help of this tool, we have full-text search accessibility. audit trails of changes made to issues. it provides the revision control system integration. revision control of text fields and notes to get more details about bug tracking tools, refer to the following link: https://www.javatpoint.com/defect-or-bug-tracking-tool. tessy another integration testing tool is tessy, which is used to perform the integration and unit testing for the embedded software. it also helps us to discover the code coverage of the software or an application. it can easily manage the entire test organization, including business needs, test management, coverage quantity, and traceability. tessy contains three primary functions, which are as follows: test interface editor (tie) test data editor (tde) workspace. features of tessy the standard features of the tessy are as follows: it produces the test report for the test execution results. it supports various programming languages such as c and c++. tessy is used to evaluate the interface of the function and describes the variable used by that function. for more information about integration testing tools, refers to the following link: https://www.javatpoint.com/integration-testing-tools. overview in this article, we have seen detailed information about manual testing, which includes the definition of manual testing, the need of manual testing, type of manual testing, manual testing tools, the process of manual testing, and some important benefits and drawbacks of it. finally, we can say that, it is a process where the test engineer needs to be very persistent, innovative, and responsive. in manual testing, the test engineer needs to think and perform like end-user interpretation. in order to implement manual testing, a test engineer needs productive skill and imagination. and they need to think of multiple situations or scenarios to test a specific application. even though we can test nearly all applications with the help of automation testing at present, still manual testing is necessary as it is the base of software testing. next topicautomation testing ? prev next ? for videos join our youtube channel: join now feedback send your feedback to [email protected] help others, please share learn latest tutorials splunk spss swagger transact-sql tumblr reactjs regex reinforcement learning r programming rxjs react native python design patterns python pillow python turtle keras preparation aptitude reasoning verbal ability interview questions company questions trending technologies artificial intelligence aws selenium cloud computing hadoop reactjs data science angular 7 blockchain git machine learning devops b.tech / mca dbms data structures daa operating system computer network compiler design computer organization discrete mathematics ethical hacking computer graphics software engineering web technology cyber security automata c programming c++ java .net python programs control system data mining data warehouse javatpoint services javatpoint offers too many high quality services. mail us on [email protected], to get more information about given services. website designing website development java development php development wordpress graphic designing logo digital marketing on page and off page seo ppc content development corporate training classroom and online training data entry training for college campus javatpoint offers college campus training on core java, advance java, .net, android, hadoop, php, web technology and python. please mail your requirement at [email protected] duration: 1 week to 2 week like/subscribe us for latest updates or newsletter learn tutorialslearn javalearn data structureslearn c programminglearn c++ tutoriallearn c# tutoriallearn php tutoriallearn html tutoriallearn javascript tutoriallearn jquery tutoriallearn spring tutorial our websitesjavatpoint.comhindi100.comlyricsia.comquoteperson.comjobandplacement.com our services website development android development website designing digital marketing summer training industrial training college campus training contact address: g-13, 2nd floor, sec-3 noida, up, 201301, india contact no: 0120-4256464, 9990449935contact us subscribe us privacy policysitemap about me ? copyright 2011-2021 www.javatpoint.com. all rights reserved. developed by javatpoint.